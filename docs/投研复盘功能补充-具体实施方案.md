# æŠ•ç ”å¤ç›˜åŠŸèƒ½è¡¥å…… - å…·ä½“å®æ–½æ–¹æ¡ˆ

> **æ–‡æ¡£ç±»å‹**: æŠ€æœ¯å®æ–½æ–¹æ¡ˆ
> **é¡¹ç›®**: russ_trading æŠ•ç ”å¤ç›˜ç³»ç»Ÿ
> **æ–¹æ¡ˆåˆ¶å®š**: 2025-11-14
> **ç›®æ ‡å‘¨æœŸ**: 1ä¸ªæœˆ (4å‘¨è¿­ä»£)
> **è´Ÿè´£äºº**: russ

---

## ğŸ“‹ ç›®å½•

1. [è°ƒç ”æ€»ç»“](#è°ƒç ”æ€»ç»“)
2. [æ€»ä½“æ¶æ„](#æ€»ä½“æ¶æ„)
3. [ç¬¬1å‘¨å®æ–½æ–¹æ¡ˆ](#ç¬¬1å‘¨å®æ–½æ–¹æ¡ˆ-åŠ¨æ€æ­¢æŸ--æç«¯åœºæ™¯)
4. [ç¬¬2-3å‘¨å®æ–½æ–¹æ¡ˆ](#ç¬¬2-3å‘¨å®æ–½æ–¹æ¡ˆ-æµåŠ¨æ€§åˆ†æ--é£é™©é¢„ç®—)
5. [ç¬¬4å‘¨å®æ–½æ–¹æ¡ˆ](#ç¬¬4å‘¨å®æ–½æ–¹æ¡ˆ-äº‹ä»¶æ—¥å†--å†å²å›æµ‹)
6. [æŠ€æœ¯ç»†èŠ‚](#æŠ€æœ¯ç»†èŠ‚)
7. [è´¨é‡ä¿è¯](#è´¨é‡ä¿è¯)
8. [é£é™©ä¸åº”å¯¹](#é£é™©ä¸åº”å¯¹)

---

## ğŸ“Š è°ƒç ”æ€»ç»“

### ç°æœ‰ä»£ç åŸºç¡€ (âœ… ä¼˜ç§€)

ç»è¿‡ä»£ç ç»“æ„æ¢ç´¢,å‘ç°ç°æœ‰ç³»ç»Ÿå·²ç»å…·å¤‡**éå¸¸åšå®çš„åŸºç¡€**:

| æ¨¡å— | çŠ¶æ€ | ç°æœ‰åŠŸèƒ½ | éœ€æ‰©å±•åŠŸèƒ½ |
|------|------|---------|-----------|
| **risk_manager.py** | âœ… å·²æœ‰ (30KB) | 10+é£é™©æŒ‡æ ‡ (VaRã€å¤æ™®ã€è´å¡”ç­‰) | â• åŠ¨æ€æ­¢æŸè®¡ç®— |
| **stress_tester.py** | âœ… å·²æœ‰ (7KB) | 2ä¸ªå†å²å±æœºåœºæ™¯ | â• æ‰©å±•åˆ°5ä¸ªåœºæ™¯ |
| **dynamic_position_manager.py** | âœ… å·²æœ‰ (21KB) | Kellyå…¬å¼ã€æ³¢åŠ¨ç‡ç›®æ ‡ | â• é£é™©é¢„ç®—åˆ†é… |
| **backtest_engine_enhanced.py** | âœ… å·²æœ‰ (29KB) | å¢å¼ºå›æµ‹å¼•æ“ | â• é€æ—¥å›æ”¾åŠŸèƒ½ |
| **liquidity_analyzer.py** | âŒ ç¼ºå¤± | æ—  | â• æ–°å»ºæµåŠ¨æ€§åˆ†æå™¨ |
| **event_calendar_analyzer.py** | âŒ ç¼ºå¤± | æ—  | â• æ–°å»ºäº‹ä»¶æ—¥å†åˆ†æå™¨ |

### æŠ¥å‘Šç”Ÿæˆç³»ç»Ÿ (âœ… å®Œå–„)

| æŠ¥å‘Šç±»å‹ | æ–‡ä»¶ | å¤§å° | é›†æˆæ–¹å¼ |
|---------|------|------|---------|
| **æ—¥æŠ¥** | `daily_position_report_generator.py` | 143KB | âœ… ç›´æ¥åœ¨ç°æœ‰ç« èŠ‚åæ·»åŠ  |
| **å‘¨æŠ¥** | `weekly_strategy_generator.py` | - | âœ… ç›´æ¥åœ¨ç°æœ‰ç« èŠ‚åæ·»åŠ  |
| **ä¸»å…¥å£** | `run_unified_analysis.py` | 61KB | âœ… ç»Ÿä¸€è°ƒç”¨,æ”¯æŒå¹¶å‘ |

### æ•°æ®æºé…ç½® (âœ… å·²é…ç½®)

ä½ç½®: `russ_trading/config/unified_config.py`

- âœ… yfinance (å…¨å¸‚åœºè¦†ç›–)
- âœ… akshare (Aè‚¡æ•°æ®)
- âœ… tushare (Aè‚¡è´¢åŠ¡æ•°æ®)

---

## ğŸ—ï¸ æ€»ä½“æ¶æ„

### åŠŸèƒ½ä¼˜å…ˆçº§çŸ©é˜µ

```
ä¼˜å…ˆçº§ | åŠŸèƒ½ | å¼€å‘é‡ | ä»·å€¼ | ä¾èµ– | å‘¨æœŸ
------|------|-------|------|------|------
ğŸ¥‡ P0 | åŠ¨æ€æ­¢æŸå»ºè®® | â­â­ å° | â­â­â­â­â­ æé«˜ | risk_manager.py | ç¬¬1å‘¨
ğŸ¥‡ P0 | æç«¯åœºæ™¯æ‰©å±• | â­ æå° | â­â­â­â­â­ æé«˜ | stress_tester.py | ç¬¬1å‘¨
ğŸ¥ˆ P1 | æµåŠ¨æ€§é£é™©åˆ†æ | â­â­ å° | â­â­â­â­ é«˜ | æ–°å»ºæ¨¡å— | ç¬¬2å‘¨
ğŸ¥ˆ P1 | é£é™©é¢„ç®—åˆ†é… | â­â­ å° | â­â­â­â­ é«˜ | dynamic_position_manager.py | ç¬¬3å‘¨
ğŸ¥‰ P2 | äº‹ä»¶æ—¥å†åˆ†æ | â­â­â­ ä¸­ | â­â­â­ ä¸­ | æ–°å»ºæ¨¡å— | ç¬¬4å‘¨
ğŸ¥‰ P3 | å†å²å›æµ‹å®Œå–„ | â­â­â­â­ å¤§ | â­â­â­ ä¸­ | backtest_engine_enhanced.py | åå»¶ |
```

### æ¨¡å—ä¾èµ–å…³ç³»å›¾

```
russ_trading/
â”œâ”€â”€ managers/
â”‚   â”œâ”€â”€ risk_manager.py              â† æ‰©å±•: calculate_dynamic_stop_loss()
â”‚   â””â”€â”€ dynamic_position_manager.py  â† æ‰©å±•: allocate_by_risk_budget()
â”‚
â”œâ”€â”€ analyzers/
â”‚   â”œâ”€â”€ liquidity_analyzer.py        â† æ–°å»º: æµåŠ¨æ€§åˆ†æ
â”‚   â””â”€â”€ event_calendar_analyzer.py   â† æ–°å»º: äº‹ä»¶æ—¥å†
â”‚
â”œâ”€â”€ core/
â”‚   â””â”€â”€ stress_tester.py             â† æ‰©å±•: HISTORICAL_CRISES åœºæ™¯åº“
â”‚
â”œâ”€â”€ engines/
â”‚   â””â”€â”€ backtest_engine_enhanced.py  â† å®Œå–„: é€æ—¥å›æ”¾åŠŸèƒ½ (åå»¶)
â”‚
â”œâ”€â”€ generators/
â”‚   â”œâ”€â”€ daily_position_report_generator.py   â† é›†æˆ: æ–°åŠŸèƒ½ç« èŠ‚
â”‚   â””â”€â”€ weekly_strategy_generator.py         â† é›†æˆ: æ–°åŠŸèƒ½ç« èŠ‚
â”‚
â”œâ”€â”€ data/
â”‚   â””â”€â”€ event_calendar.yaml          â† æ–°å»º: äº‹ä»¶æ—¥å†é…ç½®
â”‚
â””â”€â”€ utils/
    â””â”€â”€ config_loader.py             â† æ‰©å±•: åŠ è½½äº‹ä»¶æ—¥å†é…ç½®
```

---

## ğŸš€ ç¬¬1å‘¨å®æ–½æ–¹æ¡ˆ: åŠ¨æ€æ­¢æŸ + æç«¯åœºæ™¯

**ç›®æ ‡**: å¿«é€Ÿæå‡é£æ§èƒ½åŠ›,ç«‹å³è§æ•ˆ

**äº¤ä»˜ç‰©**:
- âœ… åŠ¨æ€æ­¢æŸå»ºè®®åŠŸèƒ½
- âœ… æç«¯åœºæ™¯æ‰©å±•åˆ°5ä¸ª
- âœ… æ—¥æŠ¥é›†æˆåŠ¨æ€æ­¢æŸç« èŠ‚
- âœ… å‘¨æŠ¥é›†æˆæç«¯åœºæ™¯ç« èŠ‚

---

### ä»»åŠ¡ 1.1: åŠ¨æ€æ­¢æŸå»ºè®® (â­â­ å°,1-2å¤©)

#### å®ç°ä½ç½®
- **æ–‡ä»¶**: `russ_trading/managers/risk_manager.py`
- **æ–¹æ³•**: æ–°å¢ `calculate_dynamic_stop_loss()`
- **è¡Œæ•°**: åœ¨ line 100 åæ–°å¢çº¦ 80-100 è¡Œä»£ç 

#### å…·ä½“ä»£ç æ–¹æ¡ˆ

```python
# russ_trading/managers/risk_manager.py (line 100åæ–°å¢)

def calculate_atr(self, prices: List[float], highs: List[float],
                  lows: List[float], period: int = 20) -> float:
    """
    è®¡ç®—ATR(å¹³å‡çœŸå®æ³¢å¹…)

    ATR = MA(True Range, period)
    True Range = max(high-low, |high-close_prev|, |low-close_prev|)

    Args:
        prices: æ”¶ç›˜ä»·åºåˆ—
        highs: æœ€é«˜ä»·åºåˆ—
        lows: æœ€ä½ä»·åºåˆ—
        period: è®¡ç®—å‘¨æœŸ (é»˜è®¤20æ—¥)

    Returns:
        ATRå€¼ (ç»å¯¹å€¼)
    """
    if len(prices) < period + 1:
        return 0.0

    true_ranges = []
    for i in range(1, len(prices)):
        high = highs[i]
        low = lows[i]
        close_prev = prices[i-1]

        tr = max(
            high - low,
            abs(high - close_prev),
            abs(low - close_prev)
        )
        true_ranges.append(tr)

    # è®¡ç®—ATR (ç®€å•ç§»åŠ¨å¹³å‡)
    atr = np.mean(true_ranges[-period:])
    return atr


def calculate_dynamic_stop_loss(
    self,
    symbol: str,
    current_price: float,
    entry_price: float,
    price_data: pd.DataFrame,
    lookback_days: int = 20,
    fixed_stop_loss: float = -0.15
) -> Dict:
    """
    è®¡ç®—åŠ¨æ€æ­¢æŸå»ºè®®

    æ ¹æ®ATR(å¹³å‡çœŸå®æ³¢å¹…)ä¸ªæ€§åŒ–è°ƒæ•´æ­¢æŸçº¿:
    - ä½æ³¢åŠ¨æ ‡çš„(ATR < 1.5%): æ”¶ç´§æ­¢æŸ (å€æ•°6-8)
    - ä¸­æ³¢åŠ¨æ ‡çš„(ATR 1.5-3%): æ­£å¸¸æ­¢æŸ (å€æ•°8-12)
    - é«˜æ³¢åŠ¨æ ‡çš„(ATR > 3%): æ”¾å®½æ­¢æŸ (å€æ•°12-15)

    Args:
        symbol: æ ‡çš„ä»£ç 
        current_price: å½“å‰ä»·æ ¼
        entry_price: ä¹°å…¥ä»·æ ¼
        price_data: ä»·æ ¼æ•°æ® (å¿…é¡»åŒ…å« 'Close', 'High', 'Low')
        lookback_days: å›æº¯å¤©æ•° (é»˜è®¤20æ—¥)
        fixed_stop_loss: å›ºå®šæ­¢æŸçº¿ (é»˜è®¤-15%)

    Returns:
        {
            'symbol': æ ‡çš„ä»£ç ,
            'atr': ATRå€¼ (ç»å¯¹å€¼),
            'atr_pct': ATRç™¾åˆ†æ¯”,
            'volatility_level': æ³¢åŠ¨ç‡ç­‰çº§ ('ä½'/'ä¸­'/'é«˜'),
            'fixed_stop_loss': å›ºå®šæ­¢æŸæ¯”ä¾‹,
            'dynamic_stop_loss': åŠ¨æ€æ­¢æŸæ¯”ä¾‹,
            'stop_loss_price': å»ºè®®æ­¢æŸä»·æ ¼,
            'current_loss': å½“å‰äºæŸæ¯”ä¾‹,
            'is_triggered': æ˜¯å¦è§¦å‘æ­¢æŸ,
            'recommendation': æ“ä½œå»ºè®®,
            'reason': åŸå› è¯´æ˜
        }
    """
    # 1. è®¡ç®—ATR
    prices = price_data['Close'].tolist()[-lookback_days-1:]
    highs = price_data['High'].tolist()[-lookback_days-1:]
    lows = price_data['Low'].tolist()[-lookback_days-1:]

    atr = self.calculate_atr(prices, highs, lows, period=lookback_days)
    atr_pct = atr / current_price  # ATRç™¾åˆ†æ¯”

    # 2. æ ¹æ®æ³¢åŠ¨ç‡ç¡®å®šæ­¢æŸå€æ•°
    if atr_pct < 0.015:  # ä½æ³¢åŠ¨ (< 1.5%)
        volatility_level = 'ä½'
        stop_loss_multiplier = 7  # æ”¶ç´§æ­¢æŸ
    elif atr_pct < 0.03:  # ä¸­æ³¢åŠ¨ (1.5% - 3%)
        volatility_level = 'ä¸­'
        stop_loss_multiplier = 10  # æ­£å¸¸æ­¢æŸ
    else:  # é«˜æ³¢åŠ¨ (> 3%)
        volatility_level = 'é«˜'
        stop_loss_multiplier = 13  # æ”¾å®½æ­¢æŸ

    # 3. è®¡ç®—åŠ¨æ€æ­¢æŸ
    dynamic_stop_loss = -atr_pct * stop_loss_multiplier

    # 4. ç¡®ä¿åŠ¨æ€æ­¢æŸåœ¨åˆç†èŒƒå›´ [-5%, -30%]
    dynamic_stop_loss = max(-0.30, min(-0.05, dynamic_stop_loss))

    # 5. è®¡ç®—æ­¢æŸä»·æ ¼
    stop_loss_price = entry_price * (1 + dynamic_stop_loss)

    # 6. è®¡ç®—å½“å‰äºæŸ
    current_loss = (current_price - entry_price) / entry_price

    # 7. åˆ¤æ–­æ˜¯å¦è§¦å‘æ­¢æŸ
    is_triggered = current_loss < dynamic_stop_loss

    # 8. ç”Ÿæˆå»ºè®®
    if is_triggered:
        recommendation = f"âš ï¸ è§¦å‘æ­¢æŸ,å»ºè®®åœ¨{stop_loss_price:.2f}å…ƒé™„è¿‘æ­¢æŸå‡ºå±€"
        reason = f"å½“å‰äºæŸ{current_loss*100:.1f}%å·²è¶…è¿‡åŠ¨æ€æ­¢æŸçº¿{dynamic_stop_loss*100:.1f}%"
    else:
        diff_pct = (dynamic_stop_loss - fixed_stop_loss) * 100
        if diff_pct > 2:
            recommendation = f"âœ… å»ºè®®æ”¾å®½æ­¢æŸè‡³{dynamic_stop_loss*100:.1f}%"
            reason = f"æ³¢åŠ¨ç‡{volatility_level}(ATR {atr_pct*100:.2f}%),æ”¾å®½æ­¢æŸé¿å…éœ‡è¡å‡ºå±€"
        elif diff_pct < -2:
            recommendation = f"âœ… å»ºè®®æ”¶ç´§æ­¢æŸè‡³{dynamic_stop_loss*100:.1f}%"
            reason = f"æ³¢åŠ¨ç‡{volatility_level}(ATR {atr_pct*100:.2f}%),æ”¶ç´§æ­¢æŸæé«˜æ•ˆç‡"
        else:
            recommendation = f"âœ… ç»´æŒå½“å‰æ­¢æŸçº¿{dynamic_stop_loss*100:.1f}%"
            reason = f"æ³¢åŠ¨ç‡{volatility_level},åŠ¨æ€æ­¢æŸä¸å›ºå®šæ­¢æŸæ¥è¿‘"

    return {
        'symbol': symbol,
        'atr': atr,
        'atr_pct': atr_pct,
        'volatility_level': volatility_level,
        'fixed_stop_loss': fixed_stop_loss,
        'dynamic_stop_loss': dynamic_stop_loss,
        'stop_loss_price': stop_loss_price,
        'current_price': current_price,
        'entry_price': entry_price,
        'current_loss': current_loss,
        'is_triggered': is_triggered,
        'recommendation': recommendation,
        'reason': reason
    }
```

#### é›†æˆåˆ°æ—¥æŠ¥

**ä½ç½®**: `russ_trading/generators/daily_position_report_generator.py`

åœ¨ç”ŸæˆæŠ¥å‘Šæ—¶æ–°å¢ä¸€ä¸ªç« èŠ‚:

```python
# åœ¨æŠ¥å‘Šç”Ÿæˆé€»è¾‘ä¸­æ·»åŠ  (çº¦åœ¨ line 500-600 é™„è¿‘)

def _generate_dynamic_stop_loss_section(self, positions: List[Dict]) -> str:
    """ç”ŸæˆåŠ¨æ€æ­¢æŸå»ºè®®ç« èŠ‚"""
    from russ_trading.managers.risk_manager import RiskManager

    lines = []
    lines.append("### ğŸ›¡ï¸ åŠ¨æ€æ­¢æŸå»ºè®®")
    lines.append("")
    lines.append("æ ¹æ®æ³¢åŠ¨ç‡ä¸ªæ€§åŒ–è°ƒæ•´æ­¢æŸçº¿:")
    lines.append("")

    # è¡¨æ ¼
    lines.append("| æ ‡çš„ | ATRæ³¢åŠ¨ç‡ | å›ºå®šæ­¢æŸ | åŠ¨æ€æ­¢æŸ | å½“å‰äºæŸ | çŠ¶æ€ |")
    lines.append("|------|----------|---------|---------|---------|------|")

    rm = RiskManager()

    for pos in positions:
        symbol = pos['symbol']
        current_price = pos['current_price']
        entry_price = pos.get('entry_price', current_price)
        price_data = pos.get('price_data')  # éœ€è¦ä»æ•°æ®æºè·å–

        if price_data is None:
            continue

        result = rm.calculate_dynamic_stop_loss(
            symbol=symbol,
            current_price=current_price,
            entry_price=entry_price,
            price_data=price_data
        )

        # æ ¼å¼åŒ–è¾“å‡º
        atr_pct = result['atr_pct'] * 100
        fixed = result['fixed_stop_loss'] * 100
        dynamic = result['dynamic_stop_loss'] * 100
        current = result['current_loss'] * 100

        status = "âš ï¸ è§¦å‘æ­¢æŸ" if result['is_triggered'] else "âœ… å®‰å…¨"

        lines.append(
            f"| {pos['asset_name']} | {atr_pct:.2f}% | "
            f"{fixed:.0f}% | {dynamic:.0f}% | {current:.1f}% | {status} |"
        )

    lines.append("")
    lines.append("**è¯´æ˜**:")
    lines.append("- ATRæ³¢åŠ¨ç‡è¶Šé«˜,æ­¢æŸçº¿è¶Šå®½æ¾,é¿å…éœ‡è¡å‡ºå±€")
    lines.append("- è§¦å‘æ­¢æŸæ—¶å»ºè®®åŠæ—¶æ­¢æŸ,æ§åˆ¶é£é™©")
    lines.append("")

    return '\n'.join(lines)
```

#### æµ‹è¯•ç”¨ä¾‹

```python
# tests/test_dynamic_stop_loss.py

import pytest
from russ_trading.managers.risk_manager import RiskManager
import pandas as pd
import numpy as np

def test_calculate_atr():
    """æµ‹è¯•ATRè®¡ç®—"""
    rm = RiskManager()

    # æ¨¡æ‹Ÿä»·æ ¼æ•°æ®
    prices = [100, 102, 101, 103, 102, 104, 103, 105, 104, 106]
    highs = [101, 103, 102, 104, 103, 105, 104, 106, 105, 107]
    lows = [99, 101, 100, 102, 101, 103, 102, 104, 103, 105]

    atr = rm.calculate_atr(prices, highs, lows, period=5)

    assert atr > 0
    assert atr < 10  # åˆç†èŒƒå›´

def test_dynamic_stop_loss_low_volatility():
    """æµ‹è¯•ä½æ³¢åŠ¨ç‡æ ‡çš„"""
    rm = RiskManager()

    # ä½æ³¢åŠ¨æ•°æ®
    price_data = pd.DataFrame({
        'Close': np.linspace(100, 101, 21),
        'High': np.linspace(100.5, 101.5, 21),
        'Low': np.linspace(99.5, 100.5, 21)
    })

    result = rm.calculate_dynamic_stop_loss(
        symbol='TEST',
        current_price=101,
        entry_price=100,
        price_data=price_data
    )

    assert result['volatility_level'] == 'ä½'
    assert result['dynamic_stop_loss'] > -0.15  # åº”è¯¥æ”¶ç´§æ­¢æŸ

def test_dynamic_stop_loss_high_volatility():
    """æµ‹è¯•é«˜æ³¢åŠ¨ç‡æ ‡çš„"""
    rm = RiskManager()

    # é«˜æ³¢åŠ¨æ•°æ®
    price_data = pd.DataFrame({
        'Close': [100 + i*(-1)**i * 5 for i in range(21)],
        'High': [105 + i*(-1)**i * 5 for i in range(21)],
        'Low': [95 + i*(-1)**i * 5 for i in range(21)]
    })

    result = rm.calculate_dynamic_stop_loss(
        symbol='TEST',
        current_price=100,
        entry_price=100,
        price_data=price_data
    )

    assert result['volatility_level'] == 'é«˜'
    assert result['dynamic_stop_loss'] < -0.15  # åº”è¯¥æ”¾å®½æ­¢æŸ
```

---

### ä»»åŠ¡ 1.2: æç«¯åœºæ™¯æ‰©å±• (â­ æå°,1å¤©)

#### å®ç°ä½ç½®
- **æ–‡ä»¶**: `russ_trading/core/stress_tester.py`
- **ä¿®æ”¹**: æ‰©å±• `HISTORICAL_CRISES` åœºæ™¯åº“
- **è¡Œæ•°**: ä¿®æ”¹çº¦ 20-30 è¡Œé…ç½®æ•°æ®

#### å…·ä½“ä»£ç æ–¹æ¡ˆ

éœ€è¦å…ˆæŸ¥çœ‹ `utils/config_loader.py` ä¸­çš„å†å²å±æœºé…ç½®:

```python
# russ_trading/utils/config_loader.py (æ–°å¢æˆ–ä¿®æ”¹)

def get_historical_crises() -> List[Dict]:
    """
    è·å–å†å²å±æœºåœºæ™¯é…ç½®

    Returns:
        å†å²å±æœºåˆ—è¡¨
    """
    return [
        # å·²æœ‰åœºæ™¯
        {
            'name': '2008å¹´å…¨çƒé‡‘èå±æœº',
            'period': '2008-09-15 to 2009-03-09',
            'market_drop': -0.50,  # æ ‡æ™®500è·Œ50%
            'duration_days': 175,
            'characteristics': 'æ¬¡è´·å±æœºã€é›·æ›¼å€’é—­ã€å…¨çƒè¡°é€€'
        },
        {
            'name': '2020å¹´æ–°å† ç–«æƒ…',
            'period': '2020-02-20 to 2020-03-23',
            'market_drop': -0.30,  # æ ‡æ™®500è·Œ30%
            'duration_days': 33,
            'characteristics': 'å…¨çƒåœæ‘†ã€æµåŠ¨æ€§å±æœºã€å¿«é€Ÿåå¼¹'
        },

        # æ–°å¢åœºæ™¯
        {
            'name': '2015å¹´Aè‚¡è‚¡ç¾',
            'period': '2015-06-12 to 2015-08-26',
            'market_drop': -0.40,  # æ²ªæ·±300è·Œ40%
            'duration_days': 75,
            'characteristics': 'æ æ†å»åŒ–ã€è¿ç»­ç†”æ–­ã€åƒè‚¡è·Œåœ'
        },
        {
            'name': '2018å¹´ä¸­ç¾è´¸æ˜“æˆ˜',
            'period': '2018-01-26 to 2018-12-24',
            'market_drop': -0.25,  # ä¸Šè¯æŒ‡æ•°è·Œ25%
            'duration_days': 332,
            'characteristics': 'æŒç»­é˜´è·Œã€å¤–éƒ¨å†²å‡»ã€æƒ…ç»ªä½è¿·'
        },
        {
            'name': '2022å¹´ä¿„ä¹Œå†²çª',
            'period': '2022-02-24 to 2022-03-15',
            'market_drop': -0.15,  # æ ‡æ™®500è·Œ15%
            'duration_days': 20,
            'characteristics': 'åœ°ç¼˜æ”¿æ²»ã€èƒ½æºæš´æ¶¨ã€é¿é™©å‡æ¸©'
        }
    ]
```

#### é›†æˆåˆ°å‘¨æŠ¥

**ä½ç½®**: `russ_trading/generators/weekly_strategy_generator.py`

åœ¨ç”Ÿæˆå‘¨æŠ¥æ—¶ä½¿ç”¨æ‰©å±•åçš„å‹åŠ›æµ‹è¯•:

```python
# åœ¨å‘¨æŠ¥ç”Ÿæˆé€»è¾‘ä¸­æ·»åŠ 

def _generate_stress_test_section(self, positions: List[Dict], total_value: float) -> str:
    """ç”Ÿæˆå‹åŠ›æµ‹è¯•ç« èŠ‚"""
    from russ_trading.core.stress_tester import StressTester

    tester = StressTester()
    result = tester.run_stress_test(positions, total_value)

    # ä½¿ç”¨ç°æœ‰çš„æ ¼å¼åŒ–æ–¹æ³•
    report = tester.format_stress_test_report(result)

    return report
```

#### éªŒè¯æ–¹æ¡ˆ

```python
# è¿è¡Œæµ‹è¯•
if __name__ == '__main__':
    from russ_trading.core.stress_tester import StressTester

    tester = StressTester()

    # éªŒè¯åœºæ™¯æ•°é‡
    assert len(tester.historical_crises) == 5, "åº”è¯¥æœ‰5ä¸ªå†å²åœºæ™¯"

    # éªŒè¯æ–°åœºæ™¯å­˜åœ¨
    crisis_names = [c['name'] for c in tester.historical_crises]
    assert '2015å¹´Aè‚¡è‚¡ç¾' in crisis_names
    assert '2018å¹´ä¸­ç¾è´¸æ˜“æˆ˜' in crisis_names
    assert '2022å¹´ä¿„ä¹Œå†²çª' in crisis_names

    print("âœ… æç«¯åœºæ™¯æ‰©å±•éªŒè¯é€šè¿‡!")
```

---

### ç¬¬1å‘¨äº¤ä»˜æ¸…å•

**ä»£ç äº¤ä»˜**:
- âœ… `risk_manager.py` æ–°å¢ `calculate_atr()` å’Œ `calculate_dynamic_stop_loss()` æ–¹æ³•
- âœ… `config_loader.py` æ‰©å±•å†å²å±æœºåœºæ™¯åˆ°5ä¸ª
- âœ… `daily_position_report_generator.py` é›†æˆåŠ¨æ€æ­¢æŸç« èŠ‚
- âœ… `weekly_strategy_generator.py` ä½¿ç”¨æ‰©å±•åçš„å‹åŠ›æµ‹è¯•

**æ–‡æ¡£äº¤ä»˜**:
- âœ… æ›´æ–° API æ–‡æ¡£
- âœ… æµ‹è¯•ç”¨ä¾‹æ–‡æ¡£

**æµ‹è¯•éªŒè¯**:
- âœ… å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%
- âœ… æ‰‹å·¥éªŒè¯æ—¥æŠ¥/å‘¨æŠ¥è¾“å‡ºæ­£ç¡®

**æ—¶é—´ä¼°ç®—**:
- åŠ¨æ€æ­¢æŸ: 1.5å¤© (ç¼–ç 1å¤© + æµ‹è¯•0.5å¤©)
- æç«¯åœºæ™¯: 0.5å¤© (é…ç½®0.3å¤© + æµ‹è¯•0.2å¤©)
- **æ€»è®¡**: 2å¤©

---

## ğŸ“… ç¬¬2-3å‘¨å®æ–½æ–¹æ¡ˆ: æµåŠ¨æ€§åˆ†æ + é£é™©é¢„ç®—

**ç›®æ ‡**: å®Œå–„é£é™©ç®¡ç†å’ŒæµåŠ¨æ€§åˆ†æ

**äº¤ä»˜ç‰©**:
- âœ… æµåŠ¨æ€§é£é™©åˆ†æåŠŸèƒ½
- âœ… é£é™©é¢„ç®—åˆ†é…åŠŸèƒ½
- âœ… æ—¥æŠ¥é›†æˆæµåŠ¨æ€§é¢„è­¦ç« èŠ‚
- âœ… å‘¨æŠ¥é›†æˆé£é™©é¢„ç®—ç« èŠ‚

---

### ä»»åŠ¡ 2.1: æµåŠ¨æ€§é£é™©åˆ†æ (â­â­ å°,2-3å¤©)

#### å®ç°ä½ç½®
- **æ–‡ä»¶**: `russ_trading/analyzers/liquidity_analyzer.py` (æ–°å»º)
- **è¡Œæ•°**: çº¦ 200-250 è¡Œä»£ç 

#### å…·ä½“ä»£ç æ–¹æ¡ˆ

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
æµåŠ¨æ€§é£é™©åˆ†æå™¨
Liquidity Risk Analyzer

é¿å…"æµåŠ¨æ€§é™·é˜±" - æƒ³å–å–ä¸æ‰çš„æ ‡çš„
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Optional
from datetime import datetime, timedelta


class LiquidityAnalyzer:
    """æµåŠ¨æ€§åˆ†æå™¨"""

    def __init__(self):
        """åˆå§‹åŒ–æµåŠ¨æ€§åˆ†æå™¨"""
        pass

    def analyze_liquidity(
        self,
        symbol: str,
        price_data: pd.DataFrame,
        position_value: float = 0,
        days: int = 20
    ) -> Dict:
        """
        åˆ†ææ ‡çš„æµåŠ¨æ€§

        æµåŠ¨æ€§è¯„åˆ† = æˆäº¤é¢æƒé‡(60%) + æ¢æ‰‹ç‡æƒé‡(30%) + ä»·å·®æƒé‡(10%)

        Args:
            symbol: æ ‡çš„ä»£ç 
            price_data: ä»·æ ¼æ•°æ® (å¿…é¡»åŒ…å« 'Close', 'Volume')
            position_value: æŒä»“å¸‚å€¼ (ç”¨äºè®¡ç®—å–å‡ºå†²å‡»)
            days: å›æº¯å¤©æ•° (é»˜è®¤20æ—¥)

        Returns:
            {
                'symbol': æ ‡çš„ä»£ç ,
                'avg_volume': å¹³å‡æˆäº¤é‡,
                'avg_amount': å¹³å‡æˆäº¤é¢ (å…ƒ),
                'avg_turnover': å¹³å‡æ¢æ‰‹ç‡,
                'bid_ask_spread': ä¹°å–ä»·å·® (å¦‚æœå¯ç”¨),
                'liquidity_score': æµåŠ¨æ€§è¯„åˆ† (0-100),
                'liquidity_level': æµåŠ¨æ€§ç­‰çº§ ('ä¼˜ç§€'/'è‰¯å¥½'/'ä¸€èˆ¬'/'ä¸è¶³'),
                'warning': é¢„è­¦ä¿¡æ¯ (å¦‚æœæœ‰),
                'sell_days_needed': å–å‡ºæ‰€éœ€å¤©æ•° (å‡è®¾ä¸å†²å‡»ä»·æ ¼)
            }
        """
        # 1. è®¡ç®—å¹³å‡æˆäº¤é‡å’Œæˆäº¤é¢
        volumes = price_data['Volume'].tail(days)
        prices = price_data['Close'].tail(days)

        avg_volume = volumes.mean()
        avg_amount = (volumes * prices).mean()  # æ—¥å‡æˆäº¤é¢

        # 2. è®¡ç®—æ¢æ‰‹ç‡ (å¦‚æœæ•°æ®å¯ç”¨)
        # å¯¹äºAè‚¡,å¯ä»¥é€šè¿‡ akshare è·å–æ¢æ‰‹ç‡
        # è¿™é‡Œç®€åŒ–å¤„ç†,é€šè¿‡æˆäº¤é‡/æµé€šè‚¡æœ¬ä¼°ç®—
        # æ³¨æ„: éœ€è¦è·å–æµé€šè‚¡æœ¬æ•°æ®
        avg_turnover = self._estimate_turnover_rate(symbol, avg_volume, avg_amount)

        # 3. è®¡ç®—ä¹°å–ä»·å·® (å¦‚æœæ•°æ®å¯ç”¨)
        bid_ask_spread = self._calculate_bid_ask_spread(price_data)

        # 4. è®¡ç®—æµåŠ¨æ€§è¯„åˆ†
        liquidity_score = self._calculate_liquidity_score(
            avg_amount, avg_turnover, bid_ask_spread
        )

        # 5. ç¡®å®šæµåŠ¨æ€§ç­‰çº§
        if liquidity_score >= 80:
            liquidity_level = 'ä¼˜ç§€'
        elif liquidity_score >= 60:
            liquidity_level = 'è‰¯å¥½'
        elif liquidity_score >= 40:
            liquidity_level = 'ä¸€èˆ¬'
        else:
            liquidity_level = 'ä¸è¶³'

        # 6. ç”Ÿæˆé¢„è­¦
        warning = None
        if avg_amount < 10_000_000:  # æ—¥å‡æˆäº¤é¢ < 1000ä¸‡
            warning = f"âš ï¸ æ—¥å‡æˆäº¤é¢ä»…{avg_amount/10000:.1f}ä¸‡,æµåŠ¨æ€§é™·é˜±é£é™©é«˜,å»ºè®®åˆ†æ‰¹å‡ä»“"
        elif liquidity_score < 40:
            warning = f"âš ï¸ æµåŠ¨æ€§è¯„åˆ†{liquidity_score}åˆ†,äº¤æ˜“éœ€è°¨æ…"

        # 7. è®¡ç®—å–å‡ºæ‰€éœ€å¤©æ•°
        sell_days_needed = 0
        if position_value > 0 and avg_amount > 0:
            # å‡è®¾æ¯å¤©æœ€å¤šå–å‡ºæ—¥å‡æˆäº¤é¢çš„10%,é¿å…å†²å‡»ä»·æ ¼
            daily_sell_limit = avg_amount * 0.10
            sell_days_needed = int(np.ceil(position_value / daily_sell_limit))

        return {
            'symbol': symbol,
            'avg_volume': avg_volume,
            'avg_amount': avg_amount,
            'avg_turnover': avg_turnover,
            'bid_ask_spread': bid_ask_spread,
            'liquidity_score': liquidity_score,
            'liquidity_level': liquidity_level,
            'warning': warning,
            'sell_days_needed': sell_days_needed
        }

    def _estimate_turnover_rate(
        self, symbol: str, avg_volume: float, avg_amount: float
    ) -> float:
        """
        ä¼°ç®—æ¢æ‰‹ç‡

        å¯¹äºAè‚¡,å¯ä»¥é€šè¿‡ akshare å®æ—¶è·å–
        å¯¹äºç¾è‚¡/æ¸¯è‚¡,æš‚æ—¶è¿”å›None

        Args:
            symbol: æ ‡çš„ä»£ç 
            avg_volume: å¹³å‡æˆäº¤é‡
            avg_amount: å¹³å‡æˆäº¤é¢

        Returns:
            æ¢æ‰‹ç‡ (0-1) æˆ– None
        """
        try:
            # å°è¯•ä» akshare è·å– (ä»…Aè‚¡)
            if '.SS' in symbol or '.SZ' in symbol:
                import akshare as ak

                # ç§»é™¤åç¼€
                code = symbol.replace('.SS', '').replace('.SZ', '')

                # è·å–å®æ—¶è¡Œæƒ…
                df = ak.stock_zh_a_spot_em()
                row = df[df['ä»£ç '] == code]

                if not row.empty:
                    turnover_rate = row['æ¢æ‰‹ç‡'].values[0]
                    return turnover_rate / 100  # è½¬ä¸ºå°æ•°

            # å…¶ä»–å¸‚åœºè¿”å› None
            return None

        except Exception as e:
            # è·å–å¤±è´¥,è¿”å› None
            return None

    def _calculate_bid_ask_spread(self, price_data: pd.DataFrame) -> Optional[float]:
        """
        è®¡ç®—ä¹°å–ä»·å·®

        æ³¨æ„: yfinance çš„ Aè‚¡æ•°æ®ä¸åŒ…å« bid/ask,ä»…ç¾è‚¡å¯ç”¨

        Args:
            price_data: ä»·æ ¼æ•°æ®

        Returns:
            ä¹°å–ä»·å·®ç™¾åˆ†æ¯” æˆ– None
        """
        try:
            if 'Bid' in price_data.columns and 'Ask' in price_data.columns:
                bid = price_data['Bid'].tail(20).mean()
                ask = price_data['Ask'].tail(20).mean()

                if bid > 0:
                    spread = (ask - bid) / bid
                    return spread

            return None

        except Exception:
            return None

    def _calculate_liquidity_score(
        self, avg_amount: float, avg_turnover: Optional[float],
        bid_ask_spread: Optional[float]
    ) -> float:
        """
        è®¡ç®—æµåŠ¨æ€§è¯„åˆ†

        æµåŠ¨æ€§è¯„åˆ† = æˆäº¤é¢æƒé‡(60%) + æ¢æ‰‹ç‡æƒé‡(30%) + ä»·å·®æƒé‡(10%)

        Args:
            avg_amount: å¹³å‡æˆäº¤é¢
            avg_turnover: å¹³å‡æ¢æ‰‹ç‡
            bid_ask_spread: ä¹°å–ä»·å·®

        Returns:
            æµåŠ¨æ€§è¯„åˆ† (0-100)
        """
        # 1. æˆäº¤é¢è¯„åˆ† (60%)
        if avg_amount >= 100_000_000:  # > 1äº¿
            amount_score = 100
        elif avg_amount >= 50_000_000:  # 5000ä¸‡-1äº¿
            amount_score = 80
        elif avg_amount >= 10_000_000:  # 1000ä¸‡-5000ä¸‡
            amount_score = 60
        elif avg_amount >= 5_000_000:  # 500ä¸‡-1000ä¸‡
            amount_score = 40
        else:  # < 500ä¸‡
            amount_score = 20

        # 2. æ¢æ‰‹ç‡è¯„åˆ† (30%)
        turnover_score = 50  # é»˜è®¤50åˆ† (æ— æ•°æ®)
        if avg_turnover is not None:
            if avg_turnover >= 0.03:  # > 3%
                turnover_score = 100
            elif avg_turnover >= 0.02:  # 2-3%
                turnover_score = 80
            elif avg_turnover >= 0.01:  # 1-2%
                turnover_score = 60
            elif avg_turnover >= 0.005:  # 0.5-1%
                turnover_score = 40
            else:  # < 0.5%
                turnover_score = 20

        # 3. ä»·å·®è¯„åˆ† (10%)
        spread_score = 50  # é»˜è®¤50åˆ† (æ— æ•°æ®)
        if bid_ask_spread is not None:
            if bid_ask_spread <= 0.001:  # <= 0.1%
                spread_score = 100
            elif bid_ask_spread <= 0.003:  # 0.1-0.3%
                spread_score = 80
            elif bid_ask_spread <= 0.005:  # 0.3-0.5%
                spread_score = 60
            elif bid_ask_spread <= 0.01:  # 0.5-1%
                spread_score = 40
            else:  # > 1%
                spread_score = 20

        # åŠ æƒæ±‚å’Œ
        liquidity_score = (
            amount_score * 0.60 +
            turnover_score * 0.30 +
            spread_score * 0.10
        )

        return liquidity_score

    def format_liquidity_report(
        self, results: List[Dict], total_value: float
    ) -> str:
        """
        æ ¼å¼åŒ–æµåŠ¨æ€§æŠ¥å‘Š

        Args:
            results: æµåŠ¨æ€§åˆ†æç»“æœåˆ—è¡¨
            total_value: æ€»å¸‚å€¼

        Returns:
            Markdownæ ¼å¼æŠ¥å‘Š
        """
        lines = []
        lines.append("### ğŸ“‰ æµåŠ¨æ€§é£é™©é¢„è­¦")
        lines.append("")
        lines.append("è¯„ä¼°å„æ ‡çš„æµåŠ¨æ€§,é¿å…æµåŠ¨æ€§é™·é˜±:")
        lines.append("")

        # è¡¨æ ¼
        lines.append("| æ ‡çš„ | æ—¥å‡æˆäº¤é¢ | æ¢æ‰‹ç‡ | æµåŠ¨æ€§è¯„åˆ† | çŠ¶æ€ | å–å‡ºå¤©æ•° |")
        lines.append("|------|-----------|--------|-----------|------|---------|")

        for r in results:
            asset_name = r.get('asset_name', r['symbol'])
            avg_amount = r['avg_amount']
            avg_turnover = r['avg_turnover']
            liquidity_score = r['liquidity_score']
            liquidity_level = r['liquidity_level']
            sell_days = r['sell_days_needed']

            # æ ¼å¼åŒ–æˆäº¤é¢
            if avg_amount >= 100_000_000:
                amount_str = f"{avg_amount/100000000:.1f}äº¿"
            else:
                amount_str = f"{avg_amount/10000:.0f}ä¸‡"

            # æ ¼å¼åŒ–æ¢æ‰‹ç‡
            if avg_turnover is not None:
                turnover_str = f"{avg_turnover*100:.1f}%"
            else:
                turnover_str = "N/A"

            # çŠ¶æ€emoji
            if liquidity_level == 'ä¼˜ç§€':
                status = "âœ… å……è¶³"
            elif liquidity_level == 'è‰¯å¥½':
                status = "âœ… è‰¯å¥½"
            elif liquidity_level == 'ä¸€èˆ¬':
                status = "ğŸŸ¡ ä¸€èˆ¬"
            else:
                status = "âš ï¸ ä¸è¶³"

            # å–å‡ºå¤©æ•°
            sell_days_str = f"{sell_days}å¤©" if sell_days > 0 else "N/A"

            lines.append(
                f"| {asset_name} | {amount_str} | {turnover_str} | "
                f"{liquidity_score:.0f}åˆ† | {status} | {sell_days_str} |"
            )

        lines.append("")

        # é¢„è­¦è¯´æ˜
        warnings = [r for r in results if r.get('warning')]
        if warnings:
            lines.append("**âš ï¸ æµåŠ¨æ€§é¢„è­¦**:")
            lines.append("")
            for r in warnings:
                lines.append(f"- {r['warning']}")
            lines.append("")

        lines.append("**è¯´æ˜**:")
        lines.append("- æµåŠ¨æ€§è¯„åˆ† = æˆäº¤é¢(60%) + æ¢æ‰‹ç‡(30%) + ä»·å·®(10%)")
        lines.append("- å–å‡ºå¤©æ•° = æŒ‰æ—¥å‡æˆäº¤é¢10%å–å‡ºæ‰€éœ€æ—¶é—´")
        lines.append("")

        return '\n'.join(lines)


if __name__ == '__main__':
    # æµ‹è¯•æµåŠ¨æ€§åˆ†æ
    la = LiquidityAnalyzer()

    # æ¨¡æ‹Ÿæ•°æ®
    price_data = pd.DataFrame({
        'Close': np.random.uniform(1.0, 1.2, 20),
        'Volume': np.random.uniform(10_000_000, 20_000_000, 20)
    })

    result = la.analyze_liquidity(
        symbol='510300.SS',
        price_data=price_data,
        position_value=100_000
    )

    print(result)
```

#### é›†æˆåˆ°æ—¥æŠ¥

```python
# daily_position_report_generator.py ä¸­æ·»åŠ 

def _generate_liquidity_section(self, positions: List[Dict]) -> str:
    """ç”ŸæˆæµåŠ¨æ€§é¢„è­¦ç« èŠ‚"""
    from russ_trading.analyzers.liquidity_analyzer import LiquidityAnalyzer

    la = LiquidityAnalyzer()
    results = []

    for pos in positions:
        price_data = pos.get('price_data')
        if price_data is None:
            continue

        result = la.analyze_liquidity(
            symbol=pos['symbol'],
            price_data=price_data,
            position_value=pos.get('current_value', 0)
        )
        result['asset_name'] = pos['asset_name']
        results.append(result)

    total_value = sum(p.get('current_value', 0) for p in positions)
    report = la.format_liquidity_report(results, total_value)

    return report
```

---

### ä»»åŠ¡ 2.2: é£é™©é¢„ç®—åˆ†é… (â­â­ å°,2-3å¤©)

#### å®ç°ä½ç½®
- **æ–‡ä»¶**: `russ_trading/managers/dynamic_position_manager.py`
- **æ–¹æ³•**: æ–°å¢ `allocate_by_risk_budget()`
- **è¡Œæ•°**: åœ¨ç°æœ‰ä»£ç åæ–°å¢çº¦ 100-120 è¡Œ

#### å…·ä½“ä»£ç æ–¹æ¡ˆ

```python
# dynamic_position_manager.py (åœ¨ç°æœ‰ä»£ç åæ–°å¢)

def calculate_var(
    self,
    current_value: float,
    daily_volatility: float,
    confidence_level: float = 0.95
) -> float:
    """
    è®¡ç®—VaR(é£é™©ä»·å€¼) - 1æ—¥, æŒ‡å®šç½®ä¿¡åº¦

    VaR = å½“å‰å¸‚å€¼ Ã— Zåˆ†æ•° Ã— æ—¥æ³¢åŠ¨ç‡

    Args:
        current_value: å½“å‰å¸‚å€¼
        daily_volatility: æ—¥æ³¢åŠ¨ç‡
        confidence_level: ç½®ä¿¡åº¦ (é»˜è®¤95%)

    Returns:
        VaRå€¼ (ç»å¯¹é‡‘é¢)
    """
    from scipy import stats

    # æ ¹æ®ç½®ä¿¡åº¦è®¡ç®—Zåˆ†æ•°
    z_score = stats.norm.ppf(confidence_level)

    # VaRè®¡ç®—
    var = current_value * z_score * daily_volatility

    return var


def allocate_by_risk_budget(
    self,
    positions: List[Dict],
    total_capital: float,
    risk_budget: float,
    confidence_level: float = 0.95
) -> Dict:
    """
    æŒ‰é£é™©é¢„ç®—åˆ†é…ä»“ä½

    æ ¸å¿ƒé€»è¾‘:
    1. è®¡ç®—æ¯ä¸ªæ ‡çš„çš„VaR(é£é™©ä»·å€¼)
    2. è®¾å®šæ€»é£é™©é¢„ç®— (å¦‚æ€»èµ„é‡‘çš„20%)
    3. æŒ‰é£é™©åˆ†é…ä»“ä½,ä½¿å¾—æ€»VaR â‰ˆ é£é™©é¢„ç®—

    Args:
        positions: æŒä»“åˆ—è¡¨,æ¯ä¸ªåŒ…å«:
            - symbol: æ ‡çš„ä»£ç 
            - current_value: å½“å‰å¸‚å€¼
            - current_ratio: å½“å‰ä»“ä½æ¯”ä¾‹
            - daily_volatility: æ—¥æ³¢åŠ¨ç‡
        total_capital: æ€»èµ„é‡‘
        risk_budget: æ€»é£é™©é¢„ç®— (ç»å¯¹é‡‘é¢)
        confidence_level: ç½®ä¿¡åº¦ (é»˜è®¤95%)

    Returns:
        {
            'total_var': å½“å‰æ€»VaR,
            'risk_budget': é£é™©é¢„ç®—,
            'over_budget': æ˜¯å¦è¶…é¢„ç®—,
            'suggestions': [
                {
                    'symbol': æ ‡çš„ä»£ç ,
                    'asset_name': æ ‡çš„åç§°,
                    'current_value': å½“å‰å¸‚å€¼,
                    'current_ratio': å½“å‰ä»“ä½æ¯”ä¾‹,
                    'var': å½“å‰VaR,
                    'var_contribution': VaRå æ¯”,
                    'suggested_ratio': å»ºè®®ä»“ä½æ¯”ä¾‹,
                    'adjustment': è°ƒæ•´å¹…åº¦,
                    'reason': è°ƒæ•´åŸå› 
                },
                ...
            ]
        }
    """
    # 1. è®¡ç®—æ¯ä¸ªæ ‡çš„çš„VaR
    for pos in positions:
        current_value = pos.get('current_value', 0)
        daily_volatility = pos.get('daily_volatility', 0)

        var = self.calculate_var(current_value, daily_volatility, confidence_level)
        pos['var'] = var

    # 2. è®¡ç®—æ€»VaR (ç®€åŒ–:ç›´æ¥æ±‚å’Œ,ä¸è€ƒè™‘ç›¸å…³æ€§)
    total_var = sum(p['var'] for p in positions)

    # 3. åˆ¤æ–­æ˜¯å¦è¶…é¢„ç®—
    over_budget = total_var > risk_budget

    # 4. è®¡ç®—å»ºè®®ä»“ä½
    suggestions = []

    if over_budget:
        # è¶…é¢„ç®—: æŒ‰VaRæ¯”ä¾‹ç¼©å‡ä»“ä½
        shrink_factor = risk_budget / total_var

        for pos in positions:
            current_value = pos.get('current_value', 0)
            current_ratio = pos.get('current_ratio', 0)
            var = pos['var']

            # å»ºè®®ä»“ä½ = å½“å‰ä»“ä½ Ã— ç¼©å‡å› å­
            suggested_ratio = current_ratio * shrink_factor
            adjustment = suggested_ratio - current_ratio

            var_contribution = var / total_var if total_var > 0 else 0

            reason = f"VaRå æ¯”{var_contribution*100:.1f}%,è¶…é¢„ç®—éœ€ç¼©å‡"

            suggestions.append({
                'symbol': pos['symbol'],
                'asset_name': pos.get('asset_name', pos['symbol']),
                'current_value': current_value,
                'current_ratio': current_ratio,
                'var': var,
                'var_contribution': var_contribution,
                'suggested_ratio': suggested_ratio,
                'adjustment': adjustment,
                'reason': reason
            })
    else:
        # æœªè¶…é¢„ç®—: å¯é€‚å½“åŠ ä»“åˆ©ç”¨é£é™©é¢„ç®—
        available_risk = risk_budget - total_var

        # æŒ‰å½“å‰VaRæ¯”ä¾‹åˆ†é…é¢å¤–é£é™©é¢„ç®—
        for pos in positions:
            current_value = pos.get('current_value', 0)
            current_ratio = pos.get('current_ratio', 0)
            var = pos['var']
            daily_volatility = pos.get('daily_volatility', 0)

            var_contribution = var / total_var if total_var > 0 else 0

            # åˆ†é…é¢å¤–é£é™©é¢„ç®—
            extra_var = available_risk * var_contribution

            # è®¡ç®—å¯å¢åŠ çš„å¸‚å€¼
            if daily_volatility > 0:
                from scipy import stats
                z_score = stats.norm.ppf(confidence_level)
                extra_value = extra_var / (z_score * daily_volatility)

                # å»ºè®®ä»“ä½
                suggested_value = current_value + extra_value
                suggested_ratio = suggested_value / total_capital

                # é™åˆ¶æœ€å¤§ä»“ä½
                suggested_ratio = min(suggested_ratio, self.max_position)
            else:
                suggested_ratio = current_ratio

            adjustment = suggested_ratio - current_ratio

            if abs(adjustment) > 0.01:  # è°ƒæ•´è¶…è¿‡1%æ‰æç¤º
                reason = f"VaRå æ¯”{var_contribution*100:.1f}%,é£é™©åˆ©ç”¨ç‡ä¸è¶³å¯åŠ ä»“"
            else:
                reason = "å½“å‰ä»“ä½åˆç†"

            suggestions.append({
                'symbol': pos['symbol'],
                'asset_name': pos.get('asset_name', pos['symbol']),
                'current_value': current_value,
                'current_ratio': current_ratio,
                'var': var,
                'var_contribution': var_contribution,
                'suggested_ratio': suggested_ratio,
                'adjustment': adjustment,
                'reason': reason
            })

    return {
        'total_var': total_var,
        'risk_budget': risk_budget,
        'over_budget': over_budget,
        'var_utilization': total_var / risk_budget if risk_budget > 0 else 0,
        'suggestions': suggestions
    }


def format_risk_budget_report(self, result: Dict, total_capital: float) -> str:
    """
    æ ¼å¼åŒ–é£é™©é¢„ç®—æŠ¥å‘Š

    Args:
        result: é£é™©é¢„ç®—åˆ†é…ç»“æœ
        total_capital: æ€»èµ„é‡‘

    Returns:
        Markdownæ ¼å¼æŠ¥å‘Š
    """
    lines = []
    lines.append("### ğŸ’° é£é™©é¢„ç®—é…ç½®å»ºè®®")
    lines.append("")

    total_var = result['total_var']
    risk_budget = result['risk_budget']
    over_budget = result['over_budget']
    var_utilization = result['var_utilization']

    lines.append(f"**æ€»é£é™©é¢„ç®—**: Â¥{risk_budget/10000:.1f}ä¸‡ (æ€»èµ„é‡‘{risk_budget/total_capital*100:.0f}%)")
    lines.append(f"**å½“å‰é£é™©æš´éœ²**: Â¥{total_var/10000:.1f}ä¸‡ ", end='')

    if over_budget:
        lines.append(f"âš ï¸ **è¶…é¢„ç®—{(var_utilization-1)*100:.0f}%**")
    else:
        lines.append(f"âœ… **åˆ©ç”¨ç‡{var_utilization*100:.0f}%**")

    lines.append("")

    # è¡¨æ ¼
    lines.append("| æ ‡çš„ | VaR(95%) | é£é™©å æ¯” | å½“å‰ä»“ä½ | å»ºè®®ä»“ä½ | è°ƒæ•´ |")
    lines.append("|------|---------|---------|---------|---------|------|")

    suggestions = result['suggestions']
    for s in suggestions:
        asset_name = s['asset_name']
        var = s['var']
        var_contribution = s['var_contribution']
        current_ratio = s['current_ratio']
        suggested_ratio = s['suggested_ratio']
        adjustment = s['adjustment']

        # è°ƒæ•´æ ‡è®°
        if adjustment > 0.01:
            adj_mark = f"åŠ {abs(adjustment)*100:.0f}% â¬†ï¸"
        elif adjustment < -0.01:
            adj_mark = f"å‡{abs(adjustment)*100:.0f}% â¬‡ï¸"
        else:
            adj_mark = "ç»´æŒ â¡ï¸"

        lines.append(
            f"| {asset_name} | Â¥{var/10000:.1f}ä¸‡ | {var_contribution*100:.0f}% | "
            f"{current_ratio*100:.0f}% | {suggested_ratio*100:.0f}% | {adj_mark} |"
        )

    lines.append("")

    # è°ƒæ•´é€»è¾‘è¯´æ˜
    lines.append("**è°ƒæ•´é€»è¾‘**:")
    lines.append("")

    if over_budget:
        lines.append("- âš ï¸ æ€»VaRè¶…é¢„ç®—,å»ºè®®æŒ‰VaRæ¯”ä¾‹ç¼©å‡å„æ ‡çš„ä»“ä½")
    else:
        lines.append("- âœ… æ€»VaRæœªè¶…é¢„ç®—,å¯é€‚å½“åŠ ä»“æé«˜é£é™©åˆ©ç”¨ç‡")

    lines.append(f"- è°ƒæ•´åæ€»VaR: Â¥{risk_budget/10000:.1f}ä¸‡ (ç¬¦åˆé¢„ç®—)")
    lines.append("")

    return '\n'.join(lines)
```

#### é›†æˆåˆ°å‘¨æŠ¥

```python
# weekly_strategy_generator.py ä¸­æ·»åŠ 

def _generate_risk_budget_section(
    self, positions: List[Dict], total_capital: float
) -> str:
    """ç”Ÿæˆé£é™©é¢„ç®—é…ç½®ç« èŠ‚"""
    from russ_trading.managers.dynamic_position_manager import DynamicPositionManager

    dpm = DynamicPositionManager()

    # è®¾å®šé£é™©é¢„ç®—ä¸ºæ€»èµ„é‡‘çš„20%
    risk_budget = total_capital * 0.20

    result = dpm.allocate_by_risk_budget(
        positions=positions,
        total_capital=total_capital,
        risk_budget=risk_budget
    )

    report = dpm.format_risk_budget_report(result, total_capital)

    return report
```

---

### ç¬¬2-3å‘¨äº¤ä»˜æ¸…å•

**ä»£ç äº¤ä»˜**:
- âœ… `liquidity_analyzer.py` æ–°å»ºæµåŠ¨æ€§åˆ†æå™¨
- âœ… `dynamic_position_manager.py` æ–°å¢ `allocate_by_risk_budget()` æ–¹æ³•
- âœ… `daily_position_report_generator.py` é›†æˆæµåŠ¨æ€§é¢„è­¦ç« èŠ‚
- âœ… `weekly_strategy_generator.py` é›†æˆé£é™©é¢„ç®—ç« èŠ‚

**æ–‡æ¡£äº¤ä»˜**:
- âœ… æ›´æ–° API æ–‡æ¡£
- âœ… æµ‹è¯•ç”¨ä¾‹æ–‡æ¡£

**æµ‹è¯•éªŒè¯**:
- âœ… å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%
- âœ… æ‰‹å·¥éªŒè¯æ—¥æŠ¥/å‘¨æŠ¥è¾“å‡ºæ­£ç¡®

**æ—¶é—´ä¼°ç®—**:
- æµåŠ¨æ€§åˆ†æ: 2.5å¤© (ç¼–ç 1.5å¤© + æµ‹è¯•1å¤©)
- é£é™©é¢„ç®—: 2.5å¤© (ç¼–ç 1.5å¤© + æµ‹è¯•1å¤©)
- **æ€»è®¡**: 5å¤©

---

## ğŸ“… ç¬¬4å‘¨å®æ–½æ–¹æ¡ˆ: äº‹ä»¶æ—¥å† + å†å²å›æµ‹

**ç›®æ ‡**: è¡¥å……äº‹ä»¶æ—¥å†å’Œå›æµ‹åŠŸèƒ½ (å¯é€‰)

**äº¤ä»˜ç‰©**:
- âœ… äº‹ä»¶æ—¥å†åˆ†æåŠŸèƒ½ (åŠè‡ªåŠ¨)
- âš ï¸ å†å²å›æµ‹å®Œå–„ (å¯åå»¶)

---

### ä»»åŠ¡ 4.1: äº‹ä»¶æ—¥å†åˆ†æ (â­â­â­ ä¸­,3-5å¤©)

#### å®ç°ä½ç½®
- **æ–‡ä»¶**: `russ_trading/analyzers/event_calendar_analyzer.py` (æ–°å»º)
- **é…ç½®**: `russ_trading/data/event_calendar.yaml` (æ–°å»º)
- **è¡Œæ•°**: çº¦ 150-200 è¡Œä»£ç 

#### å…·ä½“ä»£ç æ–¹æ¡ˆ

**æ­¥éª¤1: åˆ›å»ºäº‹ä»¶æ—¥å†é…ç½®æ–‡ä»¶**

```yaml
# russ_trading/data/event_calendar.yaml

events:
  # 2025å¹´11æœˆäº‹ä»¶
  - date: "2025-11-15"
    event: "ç¾è”å‚¨ä¸»å¸­é²å¨å°”è®²è¯"
    type: "è´§å¸æ”¿ç­–"
    markets: ["US", "HK"]
    impact_level: "é«˜"
    affected_assets:
      - "æ’ç”Ÿç§‘æŠ€ETF"
      - "çº³æŒ‡ETF"
    historical_volatility: 0.035  # å†å²å¹³å‡æ³¢åŠ¨3.5%
    notes: "è®®æ¯å‘¨æœŸ,ç§‘æŠ€è‚¡æ³¢åŠ¨åŠ å¤§"

  - date: "2025-11-18"
    event: "Aè‚¡åˆ¸å•†æ¿å—è´¢æŠ¥å­£"
    type: "è´¢æŠ¥"
    markets: ["CN"]
    sector: "è¯åˆ¸"
    impact_level: "ä¸­"
    affected_assets:
      - "è¯åˆ¸ETF"
    historical_return: 0.021  # è´¢æŠ¥å­£å‰3å¤©å¹³å‡æ¶¨2.1%
    notes: "å…³æ³¨åˆ¸å•†ç»çºªä¸šåŠ¡æ”¶å…¥"

  - date: "2025-11-20"
    event: "ä¸­å›½GDPæ•°æ®å…¬å¸ƒ"
    type: "å®è§‚æ•°æ®"
    markets: ["CN"]
    impact_level: "ä¸­"
    expected_value: "5.0%"
    affected_assets:
      - "æ²ªæ·±300ETF"
      - "è¯åˆ¸ETF"
    notes: "é¢„æœŸGDPå¢é€Ÿ5.0%,ç¬¦åˆé¢„æœŸåˆ™åˆ©å¥½"

  # 2025å¹´12æœˆäº‹ä»¶ (ç¤ºä¾‹)
  - date: "2025-12-18"
    event: "ç¾è”å‚¨è®®æ¯ä¼šè®®"
    type: "è´§å¸æ”¿ç­–"
    markets: ["US", "HK"]
    impact_level: "é«˜"
    affected_assets:
      - "æ’ç”Ÿç§‘æŠ€ETF"
      - "çº³æŒ‡ETF"
    historical_volatility: 0.042
    notes: "å¸‚åœºé¢„æœŸé™æ¯25BP"
```

**æ­¥éª¤2: åˆ›å»ºäº‹ä»¶æ—¥å†åˆ†æå™¨**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
äº‹ä»¶æ—¥å†åˆ†æå™¨
Event Calendar Analyzer

æå‰å¸ƒå±€é‡è¦äº‹ä»¶çª—å£
"""

import yaml
from typing import Dict, List, Optional
from datetime import datetime, timedelta
from pathlib import Path


class EventCalendarAnalyzer:
    """äº‹ä»¶æ—¥å†åˆ†æå™¨"""

    def __init__(self, config_path: Optional[str] = None):
        """
        åˆå§‹åŒ–äº‹ä»¶æ—¥å†åˆ†æå™¨

        Args:
            config_path: äº‹ä»¶æ—¥å†é…ç½®æ–‡ä»¶è·¯å¾„
        """
        if config_path is None:
            config_path = Path(__file__).parent.parent / 'data' / 'event_calendar.yaml'

        self.events = self._load_events(config_path)

    def _load_events(self, config_path: Path) -> List[Dict]:
        """
        åŠ è½½äº‹ä»¶æ—¥å†

        Args:
            config_path: é…ç½®æ–‡ä»¶è·¯å¾„

        Returns:
            äº‹ä»¶åˆ—è¡¨
        """
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
                return data.get('events', [])
        except Exception as e:
            print(f"âš ï¸ åŠ è½½äº‹ä»¶æ—¥å†å¤±è´¥: {e}")
            return []

    def get_upcoming_events(
        self,
        days: int = 7,
        positions: Optional[List[Dict]] = None
    ) -> List[Dict]:
        """
        è·å–æœªæ¥Nå¤©çš„é‡è¦äº‹ä»¶

        Args:
            days: æœªæ¥å¤©æ•° (é»˜è®¤7å¤©)
            positions: å½“å‰æŒä»“åˆ—è¡¨ (ç”¨äºåŒ¹é…ç›¸å…³äº‹ä»¶)

        Returns:
            ç›¸å…³äº‹ä»¶åˆ—è¡¨
        """
        today = datetime.now().date()
        end_date = today + timedelta(days=days)

        upcoming_events = []

        for event in self.events:
            event_date = datetime.strptime(event['date'], '%Y-%m-%d').date()

            if today <= event_date <= end_date:
                # å¦‚æœæœ‰æŒä»“,åªè¿”å›ç›¸å…³äº‹ä»¶
                if positions is not None:
                    affected_assets = event.get('affected_assets', [])
                    position_names = [p.get('asset_name', '') for p in positions]

                    # æ£€æŸ¥æ˜¯å¦æœ‰äº¤é›†
                    if not any(asset in ' '.join(position_names) for asset in affected_assets):
                        continue

                upcoming_events.append(event)

        # æŒ‰æ—¥æœŸæ’åº
        upcoming_events.sort(key=lambda x: x['date'])

        return upcoming_events

    def format_event_calendar_report(
        self,
        upcoming_events: List[Dict],
        positions: Optional[List[Dict]] = None
    ) -> str:
        """
        æ ¼å¼åŒ–äº‹ä»¶æ—¥å†æŠ¥å‘Š

        Args:
            upcoming_events: å³å°†å‘ç”Ÿçš„äº‹ä»¶åˆ—è¡¨
            positions: å½“å‰æŒä»“åˆ—è¡¨

        Returns:
            Markdownæ ¼å¼æŠ¥å‘Š
        """
        if not upcoming_events:
            return "### ğŸ“… æœ¬å‘¨é‡è¦äº‹ä»¶\n\næš‚æ— é‡è¦äº‹ä»¶å½±å“å½“å‰æŒä»“ã€‚\n\n"

        lines = []
        lines.append("### ğŸ“… æœ¬å‘¨é‡è¦äº‹ä»¶")
        lines.append("")

        for i, event in enumerate(upcoming_events, 1):
            event_date = event['date']
            event_name = event['event']
            event_type = event['type']
            impact_level = event['impact_level']
            markets = ', '.join(event.get('markets', []))
            affected_assets = event.get('affected_assets', [])
            notes = event.get('notes', '')

            # å†å²å½±å“
            historical_impact = ""
            if 'historical_volatility' in event:
                vol = event['historical_volatility'] * 100
                historical_impact = f"å†å²å¹³å‡æ³¢åŠ¨Â±{vol:.1f}%"
            elif 'historical_return' in event:
                ret = event['historical_return'] * 100
                historical_impact = f"å†å²å‰3å¤©å¹³å‡æ¶¨{ret:.1f}%"

            # æŒä»“æš´éœ²
            exposure = ""
            if positions and affected_assets:
                for pos in positions:
                    if any(asset in pos.get('asset_name', '') for asset in affected_assets):
                        exposure = f"ä½ æŒæœ‰{pos['asset_name']}{pos.get('current_ratio',0)*100:.0f}%,é«˜åº¦ç›¸å…³"
                        break

            # å»ºè®®
            suggestion = self._generate_event_suggestion(event, positions)

            # æ ¼å¼åŒ–è¾“å‡º
            lines.append(f"#### {i}. {event_date} {event_name}")
            lines.append(f"- **äº‹ä»¶ç±»å‹**: {event_type}")
            lines.append(f"- **å½±å“å¸‚åœº**: {markets}")
            lines.append(f"- **å½±å“ç¨‹åº¦**: {impact_level}")
            if historical_impact:
                lines.append(f"- **å†å²å½±å“**: {historical_impact}")
            if exposure:
                lines.append(f"- **æŒä»“æš´éœ²**: {exposure}")
            if suggestion:
                lines.append(f"- **å»ºè®®**: {suggestion}")
            if notes:
                lines.append(f"- **å¤‡æ³¨**: {notes}")
            lines.append("")

        return '\n'.join(lines)

    def _generate_event_suggestion(
        self, event: Dict, positions: Optional[List[Dict]]
    ) -> str:
        """
        ç”Ÿæˆäº‹ä»¶åº”å¯¹å»ºè®®

        Args:
            event: äº‹ä»¶ä¿¡æ¯
            positions: å½“å‰æŒä»“

        Returns:
            å»ºè®®æ–‡æœ¬
        """
        impact_level = event.get('impact_level', 'ä¸­')
        event_type = event['type']

        # æ ¹æ®äº‹ä»¶ç±»å‹å’Œå½±å“ç¨‹åº¦ç”Ÿæˆå»ºè®®
        if impact_level == 'é«˜':
            if event_type == 'è´§å¸æ”¿ç­–':
                return "é™ä½ç›¸å…³æ ‡çš„è‡³25%,é¢„ç•™5%ç°é‡‘åº”å¯¹æ³¢åŠ¨"
            elif event_type == 'è´¢æŠ¥':
                return "å…³æ³¨ä¸šç»©é¢„å‘Š,å¯é€‚å½“åŠ ä»“è‡³45%"
            else:
                return "å¯†åˆ‡å…³æ³¨,åšå¥½åº”å¯¹å‡†å¤‡"
        elif impact_level == 'ä¸­':
            return "è§‚æœ›ä¸ºä¸»,ä¸è°ƒæ•´ä»“ä½"
        else:
            return "å½±å“è¾ƒå°,æ­£å¸¸æŒä»“"


if __name__ == '__main__':
    # æµ‹è¯•äº‹ä»¶æ—¥å†
    eca = EventCalendarAnalyzer()

    positions = [
        {'asset_name': 'æ’ç”Ÿç§‘æŠ€ETF', 'current_ratio': 0.30},
        {'asset_name': 'è¯åˆ¸ETF', 'current_ratio': 0.40}
    ]

    upcoming_events = eca.get_upcoming_events(days=7, positions=positions)
    report = eca.format_event_calendar_report(upcoming_events, positions)

    print(report)
```

#### é›†æˆåˆ°å‘¨æŠ¥

```python
# weekly_strategy_generator.py ä¸­æ·»åŠ 

def _generate_event_calendar_section(self, positions: List[Dict]) -> str:
    """ç”Ÿæˆäº‹ä»¶æ—¥å†ç« èŠ‚"""
    from russ_trading.analyzers.event_calendar_analyzer import EventCalendarAnalyzer

    eca = EventCalendarAnalyzer()
    upcoming_events = eca.get_upcoming_events(days=7, positions=positions)
    report = eca.format_event_calendar_report(upcoming_events, positions)

    return report
```

#### ç»´æŠ¤è¯´æ˜

äº‹ä»¶æ—¥å†éœ€è¦**æ‰‹åŠ¨ç»´æŠ¤** `event_calendar.yaml` æ–‡ä»¶:

1. **æ¯æœˆåˆæ›´æ–°**: æ·»åŠ ä¸‹æœˆé‡è¦äº‹ä»¶
2. **æ•°æ®æ¥æº**:
   - è´¢ç»æ—¥å†ç½‘ç«™ (å¦‚åŒèŠ±é¡ºã€ä¸œæ–¹è´¢å¯Œ)
   - ç¾è”å‚¨å®˜ç½‘ (FOMCä¼šè®®æ—¥ç¨‹)
   - å…¬å¸è´¢æŠ¥æ—¥å†

---

### ä»»åŠ¡ 4.2: å†å²å›æµ‹å®Œå–„ (â­â­â­â­ å¤§,å¯åå»¶)

**è¯´æ˜**: æ­¤åŠŸèƒ½å¼€å‘é‡è¾ƒå¤§,å»ºè®®åå»¶åˆ°Phase 2å®æ–½ã€‚

**å¦‚éœ€å®æ–½,æ–¹æ¡ˆå¦‚ä¸‹**:

#### å®ç°ä½ç½®
- **æ–‡ä»¶**: `russ_trading/engines/backtest_engine_enhanced.py`
- **æ–¹æ³•**: æ–°å¢ `backtest_position_adjustment()`
- **è¡Œæ•°**: çº¦ 200-300 è¡Œä»£ç 

#### æ ¸å¿ƒåŠŸèƒ½

```python
# backtest_engine_enhanced.py (å¾…å®ç°)

def backtest_position_adjustment(
    self,
    original_positions: Dict,
    suggested_positions: Dict,
    start_date: str,
    end_date: str
) -> Dict:
    """
    å›æµ‹æŒä»“è°ƒæ•´å»ºè®®

    Args:
        original_positions: åŸæŒä»“ {symbol: ratio}
        suggested_positions: å»ºè®®æŒä»“ {symbol: ratio}
        start_date: å¼€å§‹æ—¥æœŸ
        end_date: ç»“æŸæ—¥æœŸ

    Returns:
        {
            'original': {æ”¶ç›Šã€å›æ’¤ã€å¤æ™®},
            'suggested': {æ”¶ç›Šã€å›æ’¤ã€å¤æ™®},
            'difference': {æ”¶ç›Šå·®å¼‚ã€å›æ’¤å·®å¼‚}
        }
    """
    # å®ç°é€»è¾‘:
    # 1. è·å–å†å²ä»·æ ¼æ•°æ®
    # 2. é€æ—¥å›æ”¾åŸæŒä»“å’Œå»ºè®®æŒä»“
    # 3. è®¡ç®—å„è‡ªçš„æ”¶ç›Šã€å›æ’¤ã€å¤æ™®æ¯”ç‡
    # 4. å¯¹æ¯”å·®å¼‚
    pass
```

**å»ºè®®**: æ­¤åŠŸèƒ½å»¶ååˆ°æœˆåº¦ä¼˜åŒ–æ—¶å®æ–½ã€‚

---

## ğŸ”§ æŠ€æœ¯ç»†èŠ‚

### æ•°æ®æºé…ç½®

æ‰€æœ‰åŠŸèƒ½åŸºäºç°æœ‰æ•°æ®æº,æ— éœ€é¢å¤–é…ç½®:

```python
# russ_trading/config/unified_config.py (å·²æœ‰)

DATA_SOURCES = {
    'yfinance': {
        'enabled': True,
        'markets': ['US', 'HK', 'CN'],
        'features': ['price', 'volume', 'atr']
    },
    'akshare': {
        'enabled': True,
        'markets': ['CN'],
        'features': ['turnover_rate', 'fund_flow']
    },
    'tushare': {
        'enabled': True,
        'markets': ['CN'],
        'features': ['financial_data']
    }
}
```

### æŠ¥å‘Šé›†æˆæ–¹å¼

**æ—¥æŠ¥é›†æˆ** (daily_position_report_generator.py):

```python
# åœ¨ç°æœ‰æŠ¥å‘Šç”Ÿæˆé€»è¾‘ä¸­æ·»åŠ æ–°ç« èŠ‚

def generate_report(self, ...):
    ...
    # åŸæœ‰ç« èŠ‚
    report += self._generate_position_section()
    report += self._generate_performance_section()

    # æ–°å¢ç« èŠ‚
    report += self._generate_dynamic_stop_loss_section()   # åŠ¨æ€æ­¢æŸ
    report += self._generate_liquidity_section()           # æµåŠ¨æ€§é¢„è­¦

    ...
```

**å‘¨æŠ¥é›†æˆ** (weekly_strategy_generator.py):

```python
# åœ¨ç°æœ‰æŠ¥å‘Šç”Ÿæˆé€»è¾‘ä¸­æ·»åŠ æ–°ç« èŠ‚

def generate_report(self, ...):
    ...
    # åŸæœ‰ç« èŠ‚
    report += self._generate_weekly_summary()
    report += self._generate_market_analysis()

    # æ–°å¢ç« èŠ‚
    report += self._generate_stress_test_section()         # æç«¯åœºæ™¯å‹åŠ›æµ‹è¯•
    report += self._generate_risk_budget_section()         # é£é™©é¢„ç®—é…ç½®
    report += self._generate_event_calendar_section()      # äº‹ä»¶æ—¥å†

    ...
```

---

## âœ… è´¨é‡ä¿è¯

### å•å…ƒæµ‹è¯•

æ¯ä¸ªæ–°åŠŸèƒ½å¿…é¡»ç¼–å†™å•å…ƒæµ‹è¯•:

```python
# tests/test_dynamic_stop_loss.py
# tests/test_liquidity_analyzer.py
# tests/test_risk_budget.py
# tests/test_event_calendar.py
```

**æµ‹è¯•è¦†ç›–ç‡è¦æ±‚**: > 80%

### ä»£ç å®¡æŸ¥

æ¯ä¸ªåŠŸèƒ½å®Œæˆå:
1. âœ… è‡ªæˆ‘ä»£ç å®¡æŸ¥ (æ£€æŸ¥å‘½åã€æ³¨é‡Šã€é€»è¾‘)
2. âœ… è¿è¡Œå•å…ƒæµ‹è¯•
3. âœ… æ‰‹å·¥éªŒè¯æŠ¥å‘Šè¾“å‡º
4. âœ… æäº¤å‰ä¸ä½ ç¡®è®¤

### æ€§èƒ½è¦æ±‚

- å•ä¸ªåŠŸèƒ½è®¡ç®—æ—¶é—´ < 5ç§’
- æ—¥æŠ¥ç”Ÿæˆæ—¶é—´ < 30ç§’
- å‘¨æŠ¥ç”Ÿæˆæ—¶é—´ < 60ç§’

---

## âš ï¸ é£é™©ä¸åº”å¯¹

### æŠ€æœ¯é£é™©

| é£é™© | æ¦‚ç‡ | å½±å“ | åº”å¯¹æªæ–½ |
|------|------|------|---------|
| æ•°æ®æºAPIå˜æ›´ | ä¸­ | é«˜ | ä½¿ç”¨ç¨³å®šç‰ˆæœ¬,æ·»åŠ å¼‚å¸¸å¤„ç† |
| è®¡ç®—æ€§èƒ½é—®é¢˜ | ä½ | ä¸­ | ä½¿ç”¨ç¼“å­˜,ä¼˜åŒ–ç®—æ³• |
| æµ‹è¯•è¦†ç›–ä¸è¶³ | ä¸­ | ä¸­ | å¼ºåˆ¶è¦æ±‚å•å…ƒæµ‹è¯• |

### ä¸šåŠ¡é£é™©

| é£é™© | æ¦‚ç‡ | å½±å“ | åº”å¯¹æªæ–½ |
|------|------|------|---------|
| åŠŸèƒ½ç†è§£åå·® | ä¸­ | é«˜ | æ¯ä¸ªåŠŸèƒ½å®Œæˆåä¸ä½ ç¡®è®¤ |
| æŠ¥å‘Šæ ¼å¼ä¸ç¬¦é¢„æœŸ | ä¸­ | ä¸­ | æä¾›ç¤ºä¾‹æŠ¥å‘Š,åŠæ—¶è°ƒæ•´ |
| äº‹ä»¶æ—¥å†ç»´æŠ¤å›°éš¾ | é«˜ | ä½ | ç®€åŒ–é…ç½®æ ¼å¼,æä¾›æ¨¡æ¿ |

---

## ğŸ“… æ€»ä½“æ—¶é—´è¡¨

| å‘¨æ¬¡ | åŠŸèƒ½ | å·¥æ—¶ | çŠ¶æ€ |
|------|------|------|------|
| **ç¬¬1å‘¨** | åŠ¨æ€æ­¢æŸ + æç«¯åœºæ™¯ | 2å¤© | â³ å¾…å¼€å§‹ |
| **ç¬¬2å‘¨** | æµåŠ¨æ€§åˆ†æ | 2.5å¤© | â³ å¾…å¼€å§‹ |
| **ç¬¬3å‘¨** | é£é™©é¢„ç®—åˆ†é… | 2.5å¤© | â³ å¾…å¼€å§‹ |
| **ç¬¬4å‘¨** | äº‹ä»¶æ—¥å† (å¯é€‰) | 3-5å¤© | â³ å¾…å¼€å§‹ |
| **Phase 2** | å†å²å›æµ‹ (åå»¶) | 1-2å‘¨ | â¸ï¸ æš‚ç¼“ |

**æ€»è®¡**: çº¦ 10-12 ä¸ªå·¥ä½œæ—¥ (2å‘¨)

---

## ğŸ¯ éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½å®Œæˆåº¦

| åŠŸèƒ½ | éªŒæ”¶æ ‡å‡† | è´Ÿè´£æ¨¡å— |
|------|---------|---------|
| **åŠ¨æ€æ­¢æŸ** | âœ… æ—¥æŠ¥æ˜¾ç¤ºå„æ ‡çš„åŠ¨æ€æ­¢æŸçº¿ | `risk_manager.py` |
| **æç«¯åœºæ™¯** | âœ… å‘¨æŠ¥åŒ…å«5ä¸ªå†å²åœºæ™¯æµ‹è¯• | `stress_tester.py` |
| **æµåŠ¨æ€§åˆ†æ** | âœ… æ—¥æŠ¥æ˜¾ç¤ºæµåŠ¨æ€§è¯„åˆ†+é¢„è­¦ | `liquidity_analyzer.py` |
| **é£é™©é¢„ç®—** | âœ… å‘¨æŠ¥æ˜¾ç¤ºé£é™©é¢„ç®—é…ç½®å»ºè®® | `dynamic_position_manager.py` |
| **äº‹ä»¶æ—¥å†** | âœ… å‘¨æŠ¥æ˜¾ç¤ºæœªæ¥7å¤©é‡è¦äº‹ä»¶ | `event_calendar_analyzer.py` |

### è´¨é‡è¦æ±‚

1. **å‡†ç¡®æ€§**: è®¡ç®—ç»“æœä¸æ‰‹å·¥éªŒè¯è¯¯å·® < 1%
2. **æ€§èƒ½**: å•ä¸ªåŠŸèƒ½è®¡ç®—æ—¶é—´ < 5ç§’
3. **å¯è¯»æ€§**: æŠ¥å‘Šè¾“å‡ºæ¸…æ™°,å»ºè®®æ˜ç¡®
4. **é²æ£’æ€§**: æ•°æ®ç¼ºå¤±æ—¶é™çº§å¤„ç†,ä¸æŠ¥é”™

---

## ğŸ“š å‚è€ƒèµ„æ–™

### å†…éƒ¨æ–‡æ¡£
- [é¡¹ç›®ä»£ç ç»“æ„æ¢ç´¢æŠ¥å‘Š](/docs/é¡¹ç›®ä»£ç ç»“æ„æ¢ç´¢æŠ¥å‘Š.md)
- [ä»£ç ç»“æ„å¿«é€Ÿå‚è€ƒ](/docs/ä»£ç ç»“æ„å¿«é€Ÿå‚è€ƒ.txt)

### å¤–éƒ¨èµ„æ–™
- yfinance: https://github.com/ranaroussi/yfinance
- akshare: https://akshare.akfamily.xyz/
- tushare: https://tushare.pro/document/2
- ATRæ­¢æŸ: Wilder's Average True Range

---

## ğŸš€ åç»­æ‰©å±• (Phase 2)

å¦‚æœéœ€è¦è¿›ä¸€æ­¥æå‡,å¯è€ƒè™‘:

1. **å¤šç­–ç•¥å›æµ‹**: åŒæ—¶å›æµ‹å¤šä¸ªè°ƒä»“ç­–ç•¥
2. **å‚æ•°ä¼˜åŒ–**: è‡ªåŠ¨å¯»æ‰¾æœ€ä¼˜æ­¢æŸå€æ•°ã€é£é™©é¢„ç®—æ¯”ä¾‹
3. **æœºå™¨å­¦ä¹ é¢„æµ‹**: åŸºäºå†å²äº‹ä»¶,é¢„æµ‹æœªæ¥å½±å“
4. **å®æ—¶é¢„è­¦**: ç›˜ä¸­ç›‘æ§è§¦å‘è‡ªåŠ¨é‚®ä»¶/çŸ­ä¿¡

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025-11-14
**ç»´æŠ¤è€…**: russ + Claude
**çŠ¶æ€**: âœ… å¾…å®¡æ ¸

---

## â“ ä¸‹ä¸€æ­¥

è¯·ä½ å®¡æ ¸è¿™ä»½å®æ–½æ–¹æ¡ˆ,ç¡®è®¤:

1. âœ… æ–¹æ¡ˆæ˜¯å¦ç¬¦åˆä½ çš„é¢„æœŸ?
2. âœ… ä¼˜å…ˆçº§å®‰æ’æ˜¯å¦åˆç†?
3. âœ… æŠ€æœ¯æ–¹æ¡ˆæ˜¯å¦å¯è¡Œ?
4. âœ… æ˜¯å¦æœ‰éœ€è¦è°ƒæ•´çš„åœ°æ–¹?

**å®¡æ ¸é€šè¿‡å,æˆ‘ä»¬å°†å¼€å§‹ç¬¬1å‘¨çš„å®æ–½å·¥ä½œ!** ğŸš€
